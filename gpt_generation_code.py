# -*- coding: utf-8 -*-
"""GPT Generation Code

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xxHHnvu-fYYYhW_-4E79UjofBQWobY-w

# import packages and API
"""

import pandas as pd
import time
import os
from tqdm.notebook import tqdm
from google.colab import files
from openai import OpenAI

# API key, taken from OpenAI account
from google.colab import userdata
api_key = userdata.get('OPENAI_API_KEY') # your OpenAI key

# Initialize OpenAI client
client = OpenAI(api_key=api_key)
print("OpenAI client initialized")

"""# load the word list and the reference"""

# Load word list and reference dictionary (KBBI definition)

words_df = pd.read_csv('word.csv')
print(f"Word list loaded successfully: {len(words_df)} words found")

word_column = "word" # the CSV column must have "word" at the top
words_list = words_df[word_column].tolist()

ref_df = pd.read_csv('reference.csv') # the CSV column for must have "word" and "definition" at the top
print(f"Reference definitions loaded successfully: {len(ref_df)} entries found")

ref_word_column = "word"
ref_def_column = "definition"

"""# define

*   the KBBI guideline with chain-of-thought prompting
*   model, parameter, and backoff function (to avoid getting rate limit with the OpenAI API)
"""

def generate_definition(word, model="gpt-4o-2024-05-13", max_tokens=500, max_retries=5): # updated model parameter
    kbbi_style_guidelines = """
You are an expert Indonesian linguist specializing in creating dictionary definitions in the style of Kamus Besar Bahasa Indonesia (KBBI).

INTERNAL INSTRUCTIONS (Do not include in output):
1. For each word, ANALYZE its part of speech
2. Choose ONE definition type UNLESS the word naturally requires more than one (e.g., analytical definition plus a synonym definition).
   - Analytical Definition (genus + differentia)
   - Encyclopedic Definition (can be detailed, but avoid to be too encyclopedic)
   - Synonym Definition (use another word with the closest or the same meaning)
   - Antonym Definition (use negation in the beginning of definition)
   - Ostensive Definition (define something as you are pointing at the object directly)
3. If needed, COMBINE multiple definitions within a single sentence using a semicolon `;`. Example: komputer: alat untuk mengolah data secara elektronik; laptop
4. CREATE the definition following KBBI principles:
   - The definition must be self-explanatory
   - Avoid using words more complicated than the words being defined
   - Match the part of speech in the first word of the definition
   - Omit copula words like "adalah" and "merupakan"
   - Use simpler terms than the word being defined
   - Avoid circular definitions
   - Be specific but not too specific

OUTPUT FORMAT:
Return ONLY the definition with no explanations, headers, or additional text.

REFERENCE EXAMPLES:
Analytical Definition — pohon: tumbuhan yang berbatang keras dan besar; pokok kayu
Encyclopedic Definition — matahari: benda angkasa, titik pusat tata surya berupa bola berisi gas yang mendatangkan terang dan panas pada bumi pada siang hari
Synonym Definition — kudus: suci; murni
Antonym Definition — nirkabel: tanpa menggunakan kabel
Ostensive Definition — biru: warna dasar yg serupa dng warna langit yg terang (tidak berawan dan sebagainya) serta merupakan warna asli (bukan hasil campuran beberapa warna)
"""

    prompt = f"""
Kata: {word}
Definisi:
"""

    for attempt in range(max_retries):
        try:
            response = client.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": kbbi_style_guidelines},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=max_tokens,
                temperature=0.3  # temperature can be adjusted here
            )
            definition = response.choices[0].message.content.strip()

            return definition

        except Exception as e:
            print(f"Error generating definition for '{word}' (attempt {attempt+1}/{max_retries}): {e}")
            if "rate_limit" in str(e).lower():
                wait_time = (2 ** attempt) * 10  # Exponential backoff
                print(f"Rate limited. Waiting {wait_time} seconds...")
                time.sleep(wait_time)
            else:
                time.sleep(5) # backoff function

    return f"Error: Failed to generate definition after {max_retries} attempts"

"""# generate"""

results = []
print(f"Generating definitions for {len(words_list)} words...")

for word in tqdm(words_list):
    definition = generate_definition(word)

    # find the reference
    reference_def = None
    if ref_df is not None:
        match = ref_df[ref_df[ref_word_column] == word]
        if not match.empty:
            reference_def = match.iloc[0][ref_def_column]

    result = {
        "word": word,
        "generated_definition": definition,
    }

    if reference_def:
        result["reference_definition"] = reference_def

    results.append(result)
    # avoiding rate limits
    time.sleep(1)

results_df = pd.DataFrame(results)

"""# save file"""

# clean the generated result so it will only extract the definition
for result in results:
    word = result["word"]
    definition = result["generated_definition"]

    # remove any format where the word is followed by colon
    import re
    pattern = r'^' + re.escape(word) + r'\s*:\s*'
    definition = re.sub(pattern, '', definition, flags=re.IGNORECASE).strip()

    # handle cases where only a colon appears at the beginning
    definition = re.sub(r'^:\s*', '', definition).strip()

    # remove the word if it still appears at the beginning (without colon)
    if definition.lower().startswith(word.lower()):
        word_pattern = r'^' + re.escape(word) + r'\s*\d*\.?\s*'
        definition = re.sub(word_pattern, '', definition, flags=re.IGNORECASE).strip()

    # handle any remaining numbering patterns at the beginning
    definition = re.sub(r'^(\d+\.?\s*)', '', definition).strip()

    result["generated_definition"] = definition

results_df = pd.DataFrame(results)

# save as CSV
output_filename = "generated_definitions.csv"
results_df.to_csv(output_filename, index=False)
files.download(output_filename)

print(f"Generated definitions saved to {output_filename}")

print("Generation complete")

"""# semantic similarity"""

import pandas as pd
import numpy as np
from sentence_transformers import SentenceTransformer
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm.notebook import tqdm

!pip install -q sentence-transformers

# load generated definitions CSV
df = pd.read_csv('generated_definitions.csv')

eval_df = df.dropna(subset=['generated_definition', 'reference_definition']).copy()

# Load IndoSBERT
model = SentenceTransformer('denaya/indoSBERT-large')  # Indonesian-specific SBERT model

# function to calculate semantic similarity
def calculate_semantic_similarity(text1, text2):
    # Get embeddings
    embedding1 = model.encode([text1])[0]
    embedding2 = model.encode([text2])[0]

    # Calculate cosine similarity
    from sklearn.metrics.pairwise import cosine_similarity
    similarity = cosine_similarity([embedding1], [embedding2])[0][0]
    return similarity

print("Calculating semantic similarity scores...")
eval_df['semantic_similarity'] = [calculate_semantic_similarity(ref, gen) for ref, gen in
                                 tqdm(zip(eval_df['reference_definition'], eval_df['generated_definition']),
                                      total=len(eval_df))]

# save the evaluation results to CSV
eval_results_filename = "definition_evaluation_results.csv"
eval_df.to_csv(eval_results_filename, index=False)
print(f"\nDetailed evaluation results saved to {eval_results_filename}")